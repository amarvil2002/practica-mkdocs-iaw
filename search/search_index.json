{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"about/","title":"Acerca de","text":"<p>Estas en la p\u00e1gina web de Adri\u00e1n Mart\u00ednez.</p>"},{"location":"practica1/","title":"LAMP Stack en Ubuntu Server","text":""},{"location":"practica1/#creacion-del-script-install_lampsh","title":"Creacion del script install_lamp.sh","text":"<p>Para empezar, tendremos nuestro directorio creado para la pr\u00e1ctica, en mi caso practica-1.1-iaw, y dentro de este directorio tendremos otro directorio llamado scripts, que ser\u00e1 donde instalaremos la pila LAMP y otras herramientas.</p> <p>En el script install_lamp tendremos el siguiente contenido:</p> <p>Empezaremos el script con <code>#!/bin/bash</code>, que es un indicador que le dice al sistema operativo que el script debe ser ejecutado utilizando el int\u00e9rprete de Bash.</p> <p>Tras esto, escribiremos tambi\u00e9n <code>set -ex</code> que mostrar\u00e1 todos los comandos que se vayan ejecutando y finalizar\u00e1 la ejecuci\u00f3n en caso de que haya alg\u00fan error. Lo siguiente ser\u00e1 actualizar los repositorios del sistema a trav\u00e9s del comando <code>apt update</code>. Tambi\u00e9n, se puede incluir el <code>apt upgrade -y</code> que actualizar\u00e1 los paquetes instalados a sus \u00faltimas versiones disponibles.</p>"},{"location":"practica1/#instalacion-de-apache","title":"Instalaci\u00f3n de Apache","text":"<p>A continuaci\u00f3n, con <code>apt install apache2 -y</code> vamos a instalar el servicio de Apache (-y se utiliza para responder \"s\u00ed\" autom\u00e1ticamente a cualquier pregunta que el proceso de instalaci\u00f3n haga, sin necesidad de intervenci\u00f3n manual). Antes de continuar, aunque no esta reflejado en nuestro script habr\u00e1 que ejecutar algunos comandos para activar y habilitar el servicio de Apache, con el comando <code>sudo systemctl start apache2</code> iniciamos el servicio y <code>sudo systemctl enable apache2</code> dejar\u00e1 activado el servidor y no se apagar\u00e1 cada vez que apaguemos la m\u00e1quina.</p> <p>Lo proximo a realizar ser\u00e1 habilitar el modulo rewrite (<code>a2enmod rewrite</code>), este m\u00f3dulo es muy \u00fatil porque permite la reescritura de URLs, lo que es importante para muchas aplicaciones web (como las que usan URLs limpias o amigables con SEO).</p> <p>Fuera de nuestro directorio scripts, tendremos un directorio llamado conf donde tendremos varios archivos de configuraci\u00f3n, en este caso vamos a hablar del archivo 000-default.conf, lo que vamos a hacer es cambiar el archivo de configuraci\u00f3n por defecto de Apache con este archivo que tiene el siguiente contenido:</p> <pre><code>&lt;VirtualHost *:80&gt;\n    #ServerName www.example.com\n    ServerAdmin webmaster@localhost\n    DocumentRoot /var/www/html/\n\n    DirectoryIndex index.php index.html\n\n    ErrorLog ${APACHE_LOG_DIR}/error.log\n    CustomLog ${APACHE_LOG_DIR}/access.log combined\n&lt;/VirtualHost&gt;\n</code></pre> <p>La directiva DirectoryIndex se utiliza para configurar el orden prioridad de los archivos que se van a mostrar cuando se accede a un directorio. En este caso, se dar\u00e1 prioridad al index.php. Una vez creado este archivo de configuraci\u00f3n, en nuestro script vamos a hacer un <code>cp ../conf/000-default.conf /etc/apache2/sites-available</code> para copiar el archivo de configuraci\u00f3n de Apache.</p>"},{"location":"practica1/#instalacion-de-php-y-mysql","title":"Instalaci\u00f3n de PHP y MySQL","text":"<p>Para que un servidor web Apache pueda procesar c\u00f3digo PHP vamos a necesitar instalar el int\u00e9rprete de PHP y algunos m\u00f3dulos adicionales. En nuestro a\u00f1adiremos el siguiente comando <code>apt install php libapache2-mod-php php-mysql -y</code>. <code>php</code> es el int\u00e9rprete de PHP, <code>libapache2-mod-php</code> permite servir p\u00e1ginas PHP desde el servidor web apache y <code>php-mysql</code> permite conectar a una base de datos MySQL desde c\u00f3digo PHP. Ser\u00e1 necesario reiniciar el servicio de Apache para que se apliquen los cambios <code>sudo systemctl restart apache2</code>.</p> <p>Lo siguiente ser\u00e1 la instalaci\u00f3n de MySQL Server <code>apt install mysql-server -y</code>, al igual que en Apache utilizaremos en el terminal <code>sudo systemctl start mysql</code> y <code>sudo systemctl enable mysql</code> para iniciar y habilitar el servicio de MySQL respectivamente. Con MySQL instalado podremos acceder a los archivos de configuraci\u00f3n en /etc/mysql/mysql.cnf, a los archivos de log en /var/log/mysql/error. y podremos acceder a MySQL con <code>sudo mysql</code>.</p> <p>Ya instalado el servicio de MySQL, volveremos a PHP y ahora vamos a tener un directorio llamado php donde tendremos un archivo llamado info.php que nos va a servir para comprobar que la instalaci\u00f3n se ha realizado correctamente. Su estructura ser\u00e1:</p> <pre><code>&lt;?php\n\nphpinfo();\n\n?&gt;\n</code></pre> <p>En nuestro script vamos a copiar el archivo de prueba de PHP en /var/www/html <code>cp ../php/index.php /var/www/html</code>. Una vez que ejecutemos nuestro script, si accedemos a nuestra direcci\u00f3n IP podremos comprobar que aparece la informaci\u00f3n de php.</p> <p></p> <p>Lo \u00faltimo que vamos a hacer en este script ser\u00e1 modificar el propietario y el grupo del directorio /var/www/html de forma recursiva, para que el usuario y grupo www-data puedan acceder a \u00e9l <code>chown -R www-data:www-data /var/www/html</code>. Este es el usuario con el que se ejecuta el servicio Apache. Una vez finalizado el script lo ejecutaremos en el terminal con <code>sudo ./install_lamp.sh</code> y comprobaremos que se ejecuta todo correctamente.</p> <p></p>"},{"location":"practica1/#creacion-del-script-install_toolssh","title":"Creaci\u00f3n del script install_tools.sh","text":"<p>En este script, para empezar, vamos a copiar las 10 primeras l\u00edneas del anterior script. Tambi\u00e9n, en nuestro directorio scripts vamos a tener el archivo .env que guarda las variables que ser\u00e1n necesarias m\u00e1s adelante para las distintas bases de datos y dem\u00e1s. Vamos a importar este archivo y lo haremos con <code>source .env</code>, en los archivos de est\u00e1 pr\u00e1ctica no se ve el .env porque los hemos a\u00f1adido en el archivo .gitignore para que no se puedan ver la informaci\u00f3n privada de ese archivo, en cambio, tenemos el .env.example que tendra el nombre de las variables pero no la informaci\u00f3n.</p>"},{"location":"practica1/#instalacion-de-phpmyadmin","title":"Instalaci\u00f3n de phpMyAdmin","text":"<p>Vamos a instalar phpMyAdmin, pero primero vamos a configurar una serie de respuestas que se hacen al instalar phpMyAdmin, en nuestro caso las vamos a automatizar. Para ello, en nuestro script a\u00f1adiremos el siguiente contenido:</p> <pre><code>echo \"phpmyadmin phpmyadmin/reconfigure-webserver multiselect apache2\" | debconf-set-selections\necho \"phpmyadmin phpmyadmin/dbconfig-install boolean true\" | debconf-set-selections\necho \"phpmyadmin phpmyadmin/mysql/app-pass password $PHPMYADMIN_APP_PASSWORD\" | debconf-set-selections\necho \"phpmyadmin phpmyadmin/app-password-confirm password $PHPMYADMIN_APP_PASSWORD\" | debconf-set-selections\n</code></pre> <p>Por orden, estas respuestas ser\u00e1n para seleccionar el servidor web que queremos configurar para ejecutar, confirmar que desea utilizar dbconfig-common para configurar la base de datos y seleccionar la contrase\u00f1a para phpMyAdmin.</p> <p>Una vez se automatize esto, procederemos a la instalaci\u00f3n de phpMyAdmin <code>apt install phpmyadmin php-mbstring php-zip php-gd php-json php-curl -y</code>. La instalaci\u00f3n tambi\u00e9n contiene una serie de paquetes que sirven para:</p> <ul> <li>php-mbstring: Incluye el m\u00f3dulo mbstring (multi-byte string) que permite administrar cadenas no-ASCII y convertir cadenas a diferentes codificaciones.</li> <li>php-zip: Permite la carga de archivos .zip a phpMyAdmin.</li> <li>php-gd: Incluye la librer\u00eda GD Graphics que permite crear y modificar im\u00e1genes.</li> <li>php-json: A\u00f1ade soporte para trabajar con el formato JSON desde PHP.</li> <li>php-curl: Permite interactuar con servidores haciendo uso de diferentes protocolos desde PHP.</li> </ul> <p>A trav\u00e9s de nuestra IP podremos acceder a phpmyadmin aunque todav\u00eda no tendremos creada ninguna base de datos ni usuario.</p> <p></p>"},{"location":"practica1/#instalacion-de-adminer","title":"Instalaci\u00f3n de adminer","text":"<p>Adminer es una alternativa a phpMyAdmin. Tiene la ventaja que se distribuye en un \u00fanico archivo .php.</p> <p>El primer paso ser\u00e1 crear un directorio para adminer en /var/www/html, en nuestro script a\u00f1adiremos <code>mkdir -p /var/www/html/adminer</code>, lo siguiente ser\u00e1 descargar el archivo de adminer con la utilidad wget <code>wget https://github.com/vrana/adminer/releases/download/v4.8.1/adminer-4.8.1-mysql.php -P /var/www/html/adminer</code>, con -P se indica la ruta donde se guardar\u00e1 el archivo, en este caso, en el directorio adminer que hemos creado anteriormente. Tambi\u00e9n, vamos a renombrar el nombre del archivo por index.php para que se muestre, utilizaremos el comando <code>mv /var/www/html/adminer/adminer-4.8.1-mysql.php /var/www/html/adminer/index.php</code>. Para terminar con adminer, modificaremos el propietario y el grupo del archivo como ya hemos en el script anterior <code>chown -R www-data:www-data /var/www/html</code>.</p> <p>Vamos a crear una base de datos de ejemplo:</p> <pre><code>mysql -u root &lt;&lt;&lt; \"DROP DATABASE IF EXISTS $DB_NAME\"\nmysql -u root &lt;&lt;&lt; \"CREATE DATABASE $DB_NAME\"\n</code></pre> <p>Y tambi\u00e9n un usuario para la base da datos creada:</p> <pre><code>mysql -u root &lt;&lt;&lt; \"DROP USER IF EXISTS '$DB_USER'@'%'\"\nmysql -u root &lt;&lt;&lt; \"CREATE USER '$DB_USER'@'%' IDENTIFIED BY '$DB_PASSWORD'\"\nmysql -u root &lt;&lt;&lt; \"GRANT ALL PRIVILEGES ON $DB_NAME.* TO '$DB_USER'@'%'\"\n</code></pre> <p>Se van a usar las variables configuradas en el archivo .env. La creaci\u00f3n de esta base de datos va a servir para poder acceder con un usuario y una contrase\u00f1a a las herramientas que hemos instalado previamente. Por ejemplo, ya podemos acceder a la base de datos en phpMyAdmin.</p> <p></p> <p>Para acceder a Adminer, habr\u00e1 que acceder con nuestra IP/adminer y podremos introducir el usuario, la contrase\u00f1a y la base de datos que vamos a utilizar.</p> <p> </p>"},{"location":"practica1/#instalacion-de-goaccess","title":"Instalaci\u00f3n de GoAccess","text":"<p>La siguiente herramienta a instalar ser\u00e1 un analizador de logs para Apache Server llamado GoAccess. Para su instalaci\u00f3n, habr\u00e1 que incluir en nuestro script install_tools.sh el comando <code>apt install goaccess -y</code>. Una vez que hemos instalado la utilidad podemos usarla para procesar los archivos de log access.log de Apache HTTP Server. Queremos tener en nuestro script un comando que parsea el archivo de log access.log y genera un archivo HTML en tiempo real. Pero antes de a\u00f1adir este comando se va a crear un directorio llamado stats dentro del directorio /var/www/html donde se podr\u00e1n consultar los informes generados con goaccess. El acceso a este directorio va a estar controlado y solo se podr\u00e1 acceder mediante un usuario y una contrase\u00f1a. En nuestro script a\u00f1adimos <code>mkdir -p /var/www/html/stats</code> para crear el directorio stats y ejecutamos GoAccess en segundo plano <code>goaccess /var/log/apache2/access.log -o /var/www/html/stats/index.html --log-format=COMBINED --real-time-html --daemonize</code> que har\u00e1 lo que ya he comentado anteriormente y para generar el archivo HTML en tiempo real es necesario abrir el puerto 7890 en el firewall de nuestra instancia.</p> <p>A continuaci\u00f3n, vamos a realizar el control de acceso a un directorio con autenticaci\u00f3n b\u00e1sica. Para ello, en nuestro directorio conf vamos a tener otro archivo de configuraci\u00f3n pero en este caso para el directorio stats, 000-default-stats que contiene:</p> <pre><code>&lt;VirtualHost *:80&gt;\n        #ServerName www.example.com\n        ServerAdmin webmaster@localhost\n        DocumentRoot /var/www/html\n\n        DirectoryIndex index.php index.html\n\n        &lt;Directory \"/var/www/html/stats\"&gt;\n          AuthType Basic\n          AuthName \"Acceso restringido\"\n          AuthBasicProvider file\n          AuthUserFile \"/etc/apache2/.htpasswd\"\n          Require valid-user\n        &lt;/Directory&gt;\n\n        ErrorLog ${APACHE_LOG_DIR}/error.log\n        CustomLog ${APACHE_LOG_DIR}/access.log combined\n&lt;/VirtualHost&gt;\n</code></pre> <p>Como podemos ver tiene una parte parecida al anterior archivo de configuraci\u00f3n con DirectoryIndex dando prioridad al index.php, pero se a\u00f1ade lo siguiente para el directorio stats: - AuthType Basic: Esta directiva indica que se va a utilizar el tipo de autenticaci\u00f3n m\u00e1s b\u00e1sico. - AuthName: Esta directiva nos permite condigurar la cadena de texto que le aparecer\u00e1 al usuario en el cuadro de di\u00e1logo. - AuthBasicProvider file: En este caso es opcional, porque la opci\u00f3n file es el valor por defecto para esta directiva. - AuthUserFile: Indica la ruta donde se encuentra el archivo de contrase\u00f1as que vamos a generar en nuestro script. - Require valid-user: Esta directiva nos permite indicar el proveedor de autenticaci\u00f3n que vamos a utilizar. La opci\u00f3n Require valid-user permite el acceso a cualquier usuario que aparezca en el archivo de contrase\u00f1as.</p> <p>Volvemos a nuestro script, y lo primero va a ser copiar el archivo de configuraci\u00f3n reci\u00e9n creado, <code>cp ../conf/000-default-stats.conf /etc/apache2/sites-available</code>. Deshabilitamos el virtualhost que ten\u00edamos antes <code>a2dissite 000-default.conf</code> y habilitamos el nuevo archivo <code>a2ensite 000-default-stats.conf</code>, recargamos la configuraci\u00f3n de apache para que se apliquen los cambios <code>systemctl reload apache2</code>. Como hemos visto en el archivo de configuraci\u00f3n se hac\u00eda referencia a /etc/apache2/.htpasswd, este archivo contiene las contrase\u00f1as para el usuario que acceder\u00e1 al directorio stats, a\u00f1adimos a nuestro script el siguiente comando <code>htpasswd -bc /etc/apache2/.htpasswd $STATS_USERNAME $STATS_PASSWORD</code>, la opci\u00f3n -b sirve para poder indicarle el nombre del usuario y la contrase\u00f1a como par\u00e1metros y las variables son las configuradas en el archivo .env</p>"},{"location":"practica1/#control-de-acceso-a-un-directorio-con-htaccess","title":"Control de acceso a un directorio con .htaccess","text":"<p>Los archivos .htaccess permiten realizar cambios en la configuraci\u00f3n del servidor web Apache sin tener que modificar los archivos principales de configuraci\u00f3n. Los archivos .htaccess contienen las directivas de configuraci\u00f3n que queremos aplicar sobre un directorio espec\u00edfico y todos sus subdirectorios. Vamos a tener un nuevo archivo de configuraci\u00f3n 000-default-htaccess.conf con el contenido:</p> <pre><code>&lt;VirtualHost *:80&gt;\n  #ServerName www.example.com\n  ServerAdmin webmaster@localhost\n  DocumentRoot /var/www/html\n\n  DirectoryIndex index.php index.html\n\n  &lt;Directory \"/var/www/html/stats\"&gt;\n    AllowOverride All\n  &lt;/Directory&gt;\n\n  ErrorLog ${APACHE_LOG_DIR}/error.log\n  CustomLog ${APACHE_LOG_DIR}/access.log combined\n&lt;/VirtualHost&gt;\n</code></pre> <p>Con la directiva AllowOverride All en la configuraci\u00f3n de Apache controla qu\u00e9 directivas de configuraci\u00f3n se pueden sobrescribir mediante un archivo .htaccess. Cuando estableces AllowOverride All, le est\u00e1s diciendo a Apache que permita que todas las directivas configurables en un archivo .htaccess anulen las configuraciones del servidor principal.</p> <p>En nuestro script vamos a copiar el archivo de configuraci\u00f3n <code>cp ../conf/000-default-htaccess.conf /etc/apache2/sites-available</code>. Deshabilitamos el archivo de configuraci\u00f3n de stats <code>a2dissite 000-default-stats.conf</code> y habilitamos el de htaccess <code>a2ensite 000-default-htaccess.conf</code>, recargamos la configuraci\u00f3n de Apache <code>systemctl reload apache2</code>. Por \u00faltimo, vamos a tener un archivo en conf llamado .htaccess que contiene:</p> <pre><code>AuthType Basic\nAuthName \"Acceso restringido\"\nAuthBasicProvider file\nAuthUserFile \"/etc/apache2/.htpasswd\"\nRequire valid-user\n</code></pre> <p>Vamos a copiar el .htaccess dentro del directorio que queremos proteger con usuario y contrase\u00f1a, que ser\u00e1 /var/www/html/stats <code>cp ../conf/.htaccess /var/www/html/stats</code>. Ya terminado el script, vamos a lanzarlo con <code>sudo ./install_tools.sh</code> y comprobaremos que funciona correctamente. Accederemos a nuestra IP/stats para comprobar si funciona en tiempo real.</p> <p> </p>"},{"location":"practica4.5/","title":"Terraform para Practica 1.11","text":"<p>Para esta pr\u00e1ctica vamos a utilizar Terraform, una herramienta de infraestructura como c\u00f3digo que permite crear, modificar y eliminar infraestructura de forma autom\u00e1tica.Puede gestionar los recursos de diferentes proveedores de servicios en la nube, como AWS.</p> <p>Antes de ejecutar la pr\u00e1ctica, vamos a necesitar la instalaci\u00f3n del plugin HashiCorp Terraform. Una vez instalado, dentro de nuestro repositorio ejecutaremos en la terminal <code>terraform init</code> para descargar los plugins necesarios del proveedor que se especifica en el archivo de configuraci\u00f3n.</p> <p>Vamos a tener 3 scripts, en el variables se definiran las variables que se utilizar\u00e1n en el script main.tf. En main.tf crearemos los grupos de seguridad, las instancias e IPs el\u00e1sticas necesarias para crear la infraestructura de la pr\u00e1ctica 1.11. En output.tf mostraremos las IPs p\u00fablicas de las instancias.</p> <p>Para la creaci\u00f3n de esta infraestructura ejecutaremos en la terminal <code>terraform apply</code> para aplicar los cambios y crear los recursos del archivo de configuraci\u00f3n en nuestra cuenta de AWS.</p> <p></p> <p></p> <p>Una vez que termine la ejecuci\u00f3n del comando iremos a AWS a comprobar que se han creado los grupos de seguridad, las IPs el\u00e1sticas y las instancias que tendr\u00e1n que tener asociados su grupo de seguridad correspondiente y una IP el\u00e1stica.</p> <p></p> <p></p> <p></p> <p></p> <p>Para eliminar los recursos que hemos creado solo habr\u00e1 que ejecutar el comando <code>terraform destroy</code>. Veremos que en AWS se habr\u00e1 eliminado todo lo creado anteriormente.</p> <p></p> <p></p> <p></p>"}]}